{"title":"User-configurable Keymaps","markdown":{"yaml":{"title":"User-configurable Keymaps","author":"Tobias Pietzsch","date":"2022-08-08","categories":["ui-behaviour","bigdataviewer"],"execute":{"echo":true}},"headingText":"User-configurable Keymaps","containsRefs":false,"markdown":"\n> How to set up user-configurable keyboard shortcuts using `ui-behaviour` and BigDataViewer's Preferences Dialog\n\n\nWhile developing the BDV Preferences dialog, a \"pattern\" has emerged of how we wire up the shortcut and action definitions. This tutorial explains the current recommended way of doing that. We give some background about using `ui-behaviour` etc. Feel free to just [skip to the end](#Recommended-pattern-for-defining-actions) for the recommended pattern.\n\n## Introduction\nIn [BigDataViewer 10.4](https://forum.image.sc/t/new-bigdataviewer-version-10-4-1/68818) we added a Preferences dialog.\nThis makes settings more user accessible, that previously could only be made through editing config files.\nIn particular, users can now easily override BigDataViewer keybindings to their liking.\n\nIt is also possible to define and switch between multiple sets of keybindings. For example, in Mastodon, we have predefined keymaps that have\n* basic BDV key bindings, but many shortcuts remapped to navigate along a cell lineage, or\n* full BDV key bindings, at the expense of more complicated shortcuts for cell lineage navigation.\n\nOn top of these users can define their own completely customised keymaps.\n\nThis is all based on `ui-bahaviour`, which several tools (BDV-based and otherwise) already use for managing shortcuts. While developing the Mastodon Preferences dialog, and now carrying over to BigDataViewer, a pattern has emerged of how we wire up the shortcut and action definitions.\nIt would be great if this would become a blueprint for actions in other tools, because a) that will make the code easier to understand and b) facilitate reuse of action definitions across projects.\n\nWe work towards the recommended pattern, from scratch, in a series of examples that you can also find [on github](https://github.com/tpietzsch/keyconfig-examples).\n\n## Setting up shortcuts through `ui-behaviour`\nLets look at a basic example of integrating `ui-beahviour` in a AWT/Swing application.\n\nWe need a minimal application to play with:\n`MainPanel` is a `JPanel` containing (only) a single `JLabel` displaying the text `\"hello\"`. The displayed text can be changed by the `setText(String)` method. We will use this to define different mock \"actions\".\n\nLet's instantiate a `MainPanel` and show it in a `JFrame`.\n\n![MainPanel showing text \"hello\"](keymap_imgs/hello.png)\n\nTo set up `ui-behaviour` for the `panel`, we first need an instance of `InputActionBindings`\n\n`InputActionBindings` bind inputs to actions.\n\nThis is of course exactly what AWT/Swing's [Key Bindings](https://docs.oracle.com/javase/tutorial/uiswing/misc/keybinding.html) framework (`InputMap`, `ActionMap`) does.\n`InputActionBindings` adds very little over that; basically only more convenient `InputMap` chaining.\n\nSide note: The initial purpose of `ui-behaviour` was to offer a similar framework for mouse clicks, scrolls, drags, etc. Modeled after `InputMap` and `ActionMap`, there are `InputTriggerMap` and `BehaviourMap`.\nAnalogous to `InputActionBindings` there is `TriggerBehaviourBindings`.\n\nAnyway, we connect the `InputActionBindings` instance to our `MainPanel` as follows.\n\n`InputActionBindings` manages a chain of `InputMap`/`ActionMap` pairs.\nAn `Actions` object encapsulates one such pair, and feeds new action definitions into it.\nWe create a new `Actions` (the constructor arguments don't matter for now) ...\n\n... and we add the pair to our `InputActionBindings` under the name \"actions\".\n\n(We could use the name later to remove, replace, or temporarily block the `InputMap`/`ActionMap` pair.)\n\nThe `actions` instance is now connected to the `panel` via `bindings`.\nWe can finally use it to add new shortcuts.\n\nThe `actions.runnableAction` method takes the following arguments\n```java\npublic void runnableAction(\n    final Runnable runnable,\n    final String name,\n    final String... defaultKeyStrokes )\n```\n1. A Runnable to run when the action is triggered.\n2. A unique name for the action (this will be used as the actions key in the underlying `InputMap`/`ActionMap`.\n3. Zero or more keystrokes that should trigger the action.\n\nHere for example, the Runnable sets the text \"Action A triggered\" in the panel label.\nIt is added under the name \"Action A\", and triggered by the \"SPACE\" key, or the \"A\" key by default.\nThe [syntax for key strokes is described here](https://github.com/scijava/ui-behaviour/wiki/InputTrigger-syntax).\n\nLet's add a few more actions.\n\nNow we can use these defined shortcuts to run these three actions (which will change the text label to \"Action A/B/C triggered\".\n![MainPanel showing text \"Action A triggered\"](keymap_imgs/Action-A-triggered.png)\nYou can find the full [example on github](https://github.com/tpietzsch/keyconfig-examples/blob/main/src/main/java/tpietzsch/Example1_SettingUpActions.java).\n\n## Making shortcuts configurable\n\nAnother goal of ui-behaviour is to make mouse and key bindings easily\nconfigurable *by the user* (for example through config files).\n\nThis is the purpose of the `Actions` constructor arguments\n```java\nvar action = new Actions( new InputTriggerConfig(), \"demo\" );\n```\nThe first argument is a `InputTriggerConfig`, and after that one or\nmore `String` contexts are given (more on that later).\n\nThe `InputTriggerConfig` contains is basically a map from action names to key bindings.\nWhen adding a new action, for example like this:\n```java\nactions.runnableAction(\n    () -> mainPanel.setText( \"Action B triggered\" ),\n\t\"Action B\",\n\t\"B\", \"shift B\" );\n```\nthen `actions` will first look into its `InputTriggerConfig` to check\nwhether any key binding is associated with the respective action name (\"Action B\").\nIf nothing is defined in the `InputTriggerConfig` then (and only then) the specified\ndefault key bindings will be used (`\"B\"` and `\"shift B\"`).\n\n### Loading shortcuts from a config file\nSo far, we just used a new, empty `InputTriggerConfig`, meaning we just get the specified defaults, which is exactly what we want for prototyping.\nIf the project becomes more mature, and we want to change the config from outside, we can load the `InputTriggerConfig` from a config file.\n\nThe `config.yaml` file looks like this:\n```\n---\n- !mapping\naction: Action A\ncontexts: [demo]\ntriggers: [SPACE, A]\n- !mapping\naction: Action B\ncontexts: [demo]\ntriggers: [N]\n```\nThe format should be more or less self-explanatory.\n\nThe loaded `config` should now map the String `\"Action A\"` to the Set of Strings `{\"SPACE\", \"A\"}`, and `\"Action B\"` to `{\"N\"}`.\nWe could set up `actions` with the loaded `config` in the constructor, and then define the same actions as in the previous example.\n\nAlternatively, we can just update the existing `Actions` with the new config.\n\nThe `config` contains bindings for \"Action A\" and \"Action B\". These will override the specified default bindings.\nSo \"Action A\" will be triggered by the \"SPACE\" or \"A\" keys, and \"Action B\" will be triggered by \"N\".\n\nThe `config` doesn't specify anything for \"Action C\", so that will be triggered by the programmatically specified defaults, that is, \"1\", \"2\", etc.\n\n### Action context\nBesides the `InputTriggerConfig`, the `Actions` constructor also requires one ore more `String... context` arguments.\n\nThe idea is that the same action (or at least action name) might occur in\ndifferent contexts, that is, different tools, different windows of the same\ntool, etc. For example, an action named \"Undo\" could occur in many contexts and\nit would be nice to be able to assign different shortcuts, depending on context.\n\nTherefore, an `InputTriggerConfig` does not directly map `action` to shortcuts, but\nrather maps `(action, context)` pairs to shortcuts, where `action` and `context`\nare both `String`s. So, for example, ``(\"Undo\", \"bdv\")`` can map to a different\nshortcut than `(\"Undo\", \"paintera\")`.\n\nThe `context` arguments given in the `Actions` constructor specify which subsets\nof key bindings defined in the `InputTriggerConfig` should be considered.\nIn the above example, we have\n```java\nvar actions = new Actions( config, \"demo\" )\n```\nThis `actions` will pick up bindings for `(\"Undo\", \"demo\")` from the config, but not `(\"Undo\", \"bdv\")` for example.\n\n### Disabled actions\n\nThere is a special trigger `\"not mapped\"` that can be used to specify that a\nparticular action should not be associated to any shortcut. For example, if we\nadd\n```\n- !mapping\naction: Action C\ncontexts: [demo]\ntriggers: [not mapped]\n```\nto the `config.yaml` file, then \"Action C\" will be disabled, that is,\nthe programmatic defaults \"1\", \"2\", etc., will not be used.\n\nYou can find the full [example on github](https://github.com/tpietzsch/keyconfig-examples/blob/main/src/main/java/tpietzsch/Example2_UsingConfigFiles.java).\n\n## Configuring shortcuts through the UI\n\nBeing able to define shortcuts through a config file is useful. The config files can be edited, and distributed between different users or computers.\n\nEven more comfortable is to be able to modify shortcuts directly through the UI, at runtime.\n\n### Preferences dialog\nFor this, we use `bdv.ui.settings.SettingsPanel`. This panel implements a typical Preferences layout (like it's used in Eclipse, for example) with a tree of preferences sections on the left, the selected section on the right, and *Apply, Ok, Cancel* buttons on the bottom. \n\nThe following `PrefererencesDialog` contains only the `SettingsPanel`, and a method `addPage()` to adds new sections (`bdv.ui.settings.SettingsPage`) to the preferences tree.\n\nLet's instantiate a `PreferencesDialog` for our example, and add a keyboard shortcut (command-comma or control-comma) to show it.\n\nNext, we want to add a preferences section for configuring shortcuts.\nThere is `bdv.ui.keymap.KeymapSettingsPage` that we can readily use.\nIn the end this will give us something like this:\n![Keymap settings in the preferences dialog](keymap_imgs/keymap-prefs.png)\nWhat remains to be done is to fill the settings page with a list of configurable actions.\n\n### CommandDescriptions\n\nSpecifially, we need to supply the `KeymapSettingsPage` with a list of existing actions, with short textual descriptions.\nThis is done by creating a `CommandDescriptions` object and adding the configurable actions.\n\nFor each action, we add its name and default shortcuts in the same way we did when creating the action, and a short description (this is just for showing to the user, so can be left empty if you're lazy...).\n\nThe other thing we need to supply to the `KeymapSettingsPage` is a `KeymapManager`.\n`KeymapManager` maintains a set of named `Keymaps` (some built-in, some user-defined).\nA `Keymap` is a simple container for a `InputTriggerConfig`, adding just a name and support for listeners to be notified when the `InputTriggerConfig` changes.\n\nOur `KeymapManager` extends the existing `AbstractKeymapManager` base class. The only thing that needs to be done is providing one or more default `Keymap`s. We can build a default keymap from the above `descriptions`. (But they could also be loaded from resources, build manually, ...)\n\nWe create a `KeyMapManager` instance and add it to the Preferences dialog (via `KeymapSettingsPage`).\n\nThe `KeyMapManager` (via its base class) exposes the user-selected keymap.\nWe set that for our `actions` object.\nWe also add a listener that refreshes `actions` keybinding when that keymap changes.\n\nThat's it. The user can now use the Preferences dialog to define custom keymaps with shortcuts to their liking, and switch between different keymaps. (Use command-comma or control-comma to show the preferences dialog).\n\nYou can find the full [example on github](https://github.com/tpietzsch/keyconfig-examples/blob/main/src/main/java/tpietzsch/Example3_PreferencesDialog.java).\n\n## Making action descriptions discoverable\n\nKeeping the list of existing actions (that is, the `CommandDescriptions`) up to date is tedious. Actions that should appear in the config dialog may be scattered through your own code and dependencies.\nThis can be somewhat automated with `CommandDescriptionProvider`s. These are scijava `@Plugin`s that can be discovered at runtime.\n\nFor discovery, we use a `CommandDescriptionsBuilder`\n\nNote the use of `DEMO_SCOPE` here. The same scope is also given in the `MyActionDescriptions` constructor. The `discoverProviders()` method takes an optional scope argument, and will only discover `CommandDescriptionProvider` that match this scope. If no scope is given, all `CommandDescriptionProvider` on the classpath will be discovered. For example within Fiji, that would include actions from Mastodon and BigDataViewer.\n\nUnfortunately, the `@Plugin` annotations do not work for classes defined in JShell (used by this notebook). As a workaround, we can add `MyActionDescriptions` manually.\n\nAfter we add everything we need to the builder, we can get the `Descriptions`.\n\nYou can find the full [example on github](https://github.com/tpietzsch/keymap-idiom/blob/main/src/main/java/tpietzsch/Example4_DiscoveringActions.java).\n\n## Recommended pattern for defining actions\n\nAction definitions in BigDataViewer and Mastodon are organized in the following way.\n\nA set of related actions is collected into a `MyActions` (for example) class.\nAction names and default shortcuts are defined as `public static final` constants, because they are used both for defining the actions, and for creating action `Descriptions`.\n\nThe actions contained in `MyActions` are described in a `public static` inner class `Descriptions extends CommandDescriptionProvider`.\n\nIn the `Descriptions` constructor, we give a scope for the respective library / tool.\nIdeally, the scope should be defined `public static` somewhere so that is can easily used outside the component to discover its actions.\nFor example, BigDataViewer uses [this scope](https://github.com/bigdataviewer/bigdataviewer-core/blob/5ee31596be002fc15502c4a5ffc08a888f12921b/src/main/java/bdv/KeyConfigScopes.java#L38).\nIf another tool (BigStitcher, BigWarp, etc.) wants to include BDV shortcuts into its customizable keymaps, they can be easily discovered like that.\n\n`MyActions` contains one `install` method that installs all actions into a provided `Actions` argument.\nIdeally, `MyActions` is stateless, and `install` method is `static`.\n\nThe remaining arguments to `install` are whatever is needed to create the actions.\nIn the example, the `mainPanel` is needed to create \"Action A\" and \"Action B\", and the `preferencesDialog` is needed to create the action to show/hide it.\n\nSo, `MyActions.install(...)` is called to install into a provided `Actions`.\nUsually every frame/panel in the application should have an `Actions` instance, which is linked to the `KeymapManager` so that keymap updates propagate correctly.\n\n\nAnd that's it...\nThis is currently the recommended way to structure and bundle action definitions.\nYou can find the full [example on github](https://github.com/tpietzsch/keymap-idiom/blob/main/src/main/java/tpietzsch/RecommendedPattern.java). \n\nSee BigDataViewer's [NavigationActions](https://github.com/bigdataviewer/bigdataviewer-core/blob/6d3c9b1904ff9e6e1617c2810c595c15080764c5/src/main/java/bdv/viewer/NavigationActions.java) as an example \"in the wild\".\nFor behaviours (mouse gestures, etc.) the structure is the same. See BigDataViewer's [TransformEventHandler2D](https://github.com/bigdataviewer/bigdataviewer-core/blob/d65e530df8a27726509f477e92c888d280b98162/src/main/java/bdv/TransformEventHandler2D.java) for example.\n\n[![](https://img.shields.io/badge/Download%20-Python%20Notebook%20On%20Github-blue)](https://github.com/imglib/imglib2-www/tree/main/blog_posts/2022-08-08-keymaps)\n","srcMarkdownNoYaml":"\n# User-configurable Keymaps\n> How to set up user-configurable keyboard shortcuts using `ui-behaviour` and BigDataViewer's Preferences Dialog\n\n\nWhile developing the BDV Preferences dialog, a \"pattern\" has emerged of how we wire up the shortcut and action definitions. This tutorial explains the current recommended way of doing that. We give some background about using `ui-behaviour` etc. Feel free to just [skip to the end](#Recommended-pattern-for-defining-actions) for the recommended pattern.\n\n## Introduction\nIn [BigDataViewer 10.4](https://forum.image.sc/t/new-bigdataviewer-version-10-4-1/68818) we added a Preferences dialog.\nThis makes settings more user accessible, that previously could only be made through editing config files.\nIn particular, users can now easily override BigDataViewer keybindings to their liking.\n\nIt is also possible to define and switch between multiple sets of keybindings. For example, in Mastodon, we have predefined keymaps that have\n* basic BDV key bindings, but many shortcuts remapped to navigate along a cell lineage, or\n* full BDV key bindings, at the expense of more complicated shortcuts for cell lineage navigation.\n\nOn top of these users can define their own completely customised keymaps.\n\nThis is all based on `ui-bahaviour`, which several tools (BDV-based and otherwise) already use for managing shortcuts. While developing the Mastodon Preferences dialog, and now carrying over to BigDataViewer, a pattern has emerged of how we wire up the shortcut and action definitions.\nIt would be great if this would become a blueprint for actions in other tools, because a) that will make the code easier to understand and b) facilitate reuse of action definitions across projects.\n\nWe work towards the recommended pattern, from scratch, in a series of examples that you can also find [on github](https://github.com/tpietzsch/keyconfig-examples).\n\n## Setting up shortcuts through `ui-behaviour`\nLets look at a basic example of integrating `ui-beahviour` in a AWT/Swing application.\n\nWe need a minimal application to play with:\n`MainPanel` is a `JPanel` containing (only) a single `JLabel` displaying the text `\"hello\"`. The displayed text can be changed by the `setText(String)` method. We will use this to define different mock \"actions\".\n\nLet's instantiate a `MainPanel` and show it in a `JFrame`.\n\n![MainPanel showing text \"hello\"](keymap_imgs/hello.png)\n\nTo set up `ui-behaviour` for the `panel`, we first need an instance of `InputActionBindings`\n\n`InputActionBindings` bind inputs to actions.\n\nThis is of course exactly what AWT/Swing's [Key Bindings](https://docs.oracle.com/javase/tutorial/uiswing/misc/keybinding.html) framework (`InputMap`, `ActionMap`) does.\n`InputActionBindings` adds very little over that; basically only more convenient `InputMap` chaining.\n\nSide note: The initial purpose of `ui-behaviour` was to offer a similar framework for mouse clicks, scrolls, drags, etc. Modeled after `InputMap` and `ActionMap`, there are `InputTriggerMap` and `BehaviourMap`.\nAnalogous to `InputActionBindings` there is `TriggerBehaviourBindings`.\n\nAnyway, we connect the `InputActionBindings` instance to our `MainPanel` as follows.\n\n`InputActionBindings` manages a chain of `InputMap`/`ActionMap` pairs.\nAn `Actions` object encapsulates one such pair, and feeds new action definitions into it.\nWe create a new `Actions` (the constructor arguments don't matter for now) ...\n\n... and we add the pair to our `InputActionBindings` under the name \"actions\".\n\n(We could use the name later to remove, replace, or temporarily block the `InputMap`/`ActionMap` pair.)\n\nThe `actions` instance is now connected to the `panel` via `bindings`.\nWe can finally use it to add new shortcuts.\n\nThe `actions.runnableAction` method takes the following arguments\n```java\npublic void runnableAction(\n    final Runnable runnable,\n    final String name,\n    final String... defaultKeyStrokes )\n```\n1. A Runnable to run when the action is triggered.\n2. A unique name for the action (this will be used as the actions key in the underlying `InputMap`/`ActionMap`.\n3. Zero or more keystrokes that should trigger the action.\n\nHere for example, the Runnable sets the text \"Action A triggered\" in the panel label.\nIt is added under the name \"Action A\", and triggered by the \"SPACE\" key, or the \"A\" key by default.\nThe [syntax for key strokes is described here](https://github.com/scijava/ui-behaviour/wiki/InputTrigger-syntax).\n\nLet's add a few more actions.\n\nNow we can use these defined shortcuts to run these three actions (which will change the text label to \"Action A/B/C triggered\".\n![MainPanel showing text \"Action A triggered\"](keymap_imgs/Action-A-triggered.png)\nYou can find the full [example on github](https://github.com/tpietzsch/keyconfig-examples/blob/main/src/main/java/tpietzsch/Example1_SettingUpActions.java).\n\n## Making shortcuts configurable\n\nAnother goal of ui-behaviour is to make mouse and key bindings easily\nconfigurable *by the user* (for example through config files).\n\nThis is the purpose of the `Actions` constructor arguments\n```java\nvar action = new Actions( new InputTriggerConfig(), \"demo\" );\n```\nThe first argument is a `InputTriggerConfig`, and after that one or\nmore `String` contexts are given (more on that later).\n\nThe `InputTriggerConfig` contains is basically a map from action names to key bindings.\nWhen adding a new action, for example like this:\n```java\nactions.runnableAction(\n    () -> mainPanel.setText( \"Action B triggered\" ),\n\t\"Action B\",\n\t\"B\", \"shift B\" );\n```\nthen `actions` will first look into its `InputTriggerConfig` to check\nwhether any key binding is associated with the respective action name (\"Action B\").\nIf nothing is defined in the `InputTriggerConfig` then (and only then) the specified\ndefault key bindings will be used (`\"B\"` and `\"shift B\"`).\n\n### Loading shortcuts from a config file\nSo far, we just used a new, empty `InputTriggerConfig`, meaning we just get the specified defaults, which is exactly what we want for prototyping.\nIf the project becomes more mature, and we want to change the config from outside, we can load the `InputTriggerConfig` from a config file.\n\nThe `config.yaml` file looks like this:\n```\n---\n- !mapping\naction: Action A\ncontexts: [demo]\ntriggers: [SPACE, A]\n- !mapping\naction: Action B\ncontexts: [demo]\ntriggers: [N]\n```\nThe format should be more or less self-explanatory.\n\nThe loaded `config` should now map the String `\"Action A\"` to the Set of Strings `{\"SPACE\", \"A\"}`, and `\"Action B\"` to `{\"N\"}`.\nWe could set up `actions` with the loaded `config` in the constructor, and then define the same actions as in the previous example.\n\nAlternatively, we can just update the existing `Actions` with the new config.\n\nThe `config` contains bindings for \"Action A\" and \"Action B\". These will override the specified default bindings.\nSo \"Action A\" will be triggered by the \"SPACE\" or \"A\" keys, and \"Action B\" will be triggered by \"N\".\n\nThe `config` doesn't specify anything for \"Action C\", so that will be triggered by the programmatically specified defaults, that is, \"1\", \"2\", etc.\n\n### Action context\nBesides the `InputTriggerConfig`, the `Actions` constructor also requires one ore more `String... context` arguments.\n\nThe idea is that the same action (or at least action name) might occur in\ndifferent contexts, that is, different tools, different windows of the same\ntool, etc. For example, an action named \"Undo\" could occur in many contexts and\nit would be nice to be able to assign different shortcuts, depending on context.\n\nTherefore, an `InputTriggerConfig` does not directly map `action` to shortcuts, but\nrather maps `(action, context)` pairs to shortcuts, where `action` and `context`\nare both `String`s. So, for example, ``(\"Undo\", \"bdv\")`` can map to a different\nshortcut than `(\"Undo\", \"paintera\")`.\n\nThe `context` arguments given in the `Actions` constructor specify which subsets\nof key bindings defined in the `InputTriggerConfig` should be considered.\nIn the above example, we have\n```java\nvar actions = new Actions( config, \"demo\" )\n```\nThis `actions` will pick up bindings for `(\"Undo\", \"demo\")` from the config, but not `(\"Undo\", \"bdv\")` for example.\n\n### Disabled actions\n\nThere is a special trigger `\"not mapped\"` that can be used to specify that a\nparticular action should not be associated to any shortcut. For example, if we\nadd\n```\n- !mapping\naction: Action C\ncontexts: [demo]\ntriggers: [not mapped]\n```\nto the `config.yaml` file, then \"Action C\" will be disabled, that is,\nthe programmatic defaults \"1\", \"2\", etc., will not be used.\n\nYou can find the full [example on github](https://github.com/tpietzsch/keyconfig-examples/blob/main/src/main/java/tpietzsch/Example2_UsingConfigFiles.java).\n\n## Configuring shortcuts through the UI\n\nBeing able to define shortcuts through a config file is useful. The config files can be edited, and distributed between different users or computers.\n\nEven more comfortable is to be able to modify shortcuts directly through the UI, at runtime.\n\n### Preferences dialog\nFor this, we use `bdv.ui.settings.SettingsPanel`. This panel implements a typical Preferences layout (like it's used in Eclipse, for example) with a tree of preferences sections on the left, the selected section on the right, and *Apply, Ok, Cancel* buttons on the bottom. \n\nThe following `PrefererencesDialog` contains only the `SettingsPanel`, and a method `addPage()` to adds new sections (`bdv.ui.settings.SettingsPage`) to the preferences tree.\n\nLet's instantiate a `PreferencesDialog` for our example, and add a keyboard shortcut (command-comma or control-comma) to show it.\n\nNext, we want to add a preferences section for configuring shortcuts.\nThere is `bdv.ui.keymap.KeymapSettingsPage` that we can readily use.\nIn the end this will give us something like this:\n![Keymap settings in the preferences dialog](keymap_imgs/keymap-prefs.png)\nWhat remains to be done is to fill the settings page with a list of configurable actions.\n\n### CommandDescriptions\n\nSpecifially, we need to supply the `KeymapSettingsPage` with a list of existing actions, with short textual descriptions.\nThis is done by creating a `CommandDescriptions` object and adding the configurable actions.\n\nFor each action, we add its name and default shortcuts in the same way we did when creating the action, and a short description (this is just for showing to the user, so can be left empty if you're lazy...).\n\nThe other thing we need to supply to the `KeymapSettingsPage` is a `KeymapManager`.\n`KeymapManager` maintains a set of named `Keymaps` (some built-in, some user-defined).\nA `Keymap` is a simple container for a `InputTriggerConfig`, adding just a name and support for listeners to be notified when the `InputTriggerConfig` changes.\n\nOur `KeymapManager` extends the existing `AbstractKeymapManager` base class. The only thing that needs to be done is providing one or more default `Keymap`s. We can build a default keymap from the above `descriptions`. (But they could also be loaded from resources, build manually, ...)\n\nWe create a `KeyMapManager` instance and add it to the Preferences dialog (via `KeymapSettingsPage`).\n\nThe `KeyMapManager` (via its base class) exposes the user-selected keymap.\nWe set that for our `actions` object.\nWe also add a listener that refreshes `actions` keybinding when that keymap changes.\n\nThat's it. The user can now use the Preferences dialog to define custom keymaps with shortcuts to their liking, and switch between different keymaps. (Use command-comma or control-comma to show the preferences dialog).\n\nYou can find the full [example on github](https://github.com/tpietzsch/keyconfig-examples/blob/main/src/main/java/tpietzsch/Example3_PreferencesDialog.java).\n\n## Making action descriptions discoverable\n\nKeeping the list of existing actions (that is, the `CommandDescriptions`) up to date is tedious. Actions that should appear in the config dialog may be scattered through your own code and dependencies.\nThis can be somewhat automated with `CommandDescriptionProvider`s. These are scijava `@Plugin`s that can be discovered at runtime.\n\nFor discovery, we use a `CommandDescriptionsBuilder`\n\nNote the use of `DEMO_SCOPE` here. The same scope is also given in the `MyActionDescriptions` constructor. The `discoverProviders()` method takes an optional scope argument, and will only discover `CommandDescriptionProvider` that match this scope. If no scope is given, all `CommandDescriptionProvider` on the classpath will be discovered. For example within Fiji, that would include actions from Mastodon and BigDataViewer.\n\nUnfortunately, the `@Plugin` annotations do not work for classes defined in JShell (used by this notebook). As a workaround, we can add `MyActionDescriptions` manually.\n\nAfter we add everything we need to the builder, we can get the `Descriptions`.\n\nYou can find the full [example on github](https://github.com/tpietzsch/keymap-idiom/blob/main/src/main/java/tpietzsch/Example4_DiscoveringActions.java).\n\n## Recommended pattern for defining actions\n\nAction definitions in BigDataViewer and Mastodon are organized in the following way.\n\nA set of related actions is collected into a `MyActions` (for example) class.\nAction names and default shortcuts are defined as `public static final` constants, because they are used both for defining the actions, and for creating action `Descriptions`.\n\nThe actions contained in `MyActions` are described in a `public static` inner class `Descriptions extends CommandDescriptionProvider`.\n\nIn the `Descriptions` constructor, we give a scope for the respective library / tool.\nIdeally, the scope should be defined `public static` somewhere so that is can easily used outside the component to discover its actions.\nFor example, BigDataViewer uses [this scope](https://github.com/bigdataviewer/bigdataviewer-core/blob/5ee31596be002fc15502c4a5ffc08a888f12921b/src/main/java/bdv/KeyConfigScopes.java#L38).\nIf another tool (BigStitcher, BigWarp, etc.) wants to include BDV shortcuts into its customizable keymaps, they can be easily discovered like that.\n\n`MyActions` contains one `install` method that installs all actions into a provided `Actions` argument.\nIdeally, `MyActions` is stateless, and `install` method is `static`.\n\nThe remaining arguments to `install` are whatever is needed to create the actions.\nIn the example, the `mainPanel` is needed to create \"Action A\" and \"Action B\", and the `preferencesDialog` is needed to create the action to show/hide it.\n\nSo, `MyActions.install(...)` is called to install into a provided `Actions`.\nUsually every frame/panel in the application should have an `Actions` instance, which is linked to the `KeymapManager` so that keymap updates propagate correctly.\n\n\nAnd that's it...\nThis is currently the recommended way to structure and bundle action definitions.\nYou can find the full [example on github](https://github.com/tpietzsch/keymap-idiom/blob/main/src/main/java/tpietzsch/RecommendedPattern.java). \n\nSee BigDataViewer's [NavigationActions](https://github.com/bigdataviewer/bigdataviewer-core/blob/6d3c9b1904ff9e6e1617c2810c595c15080764c5/src/main/java/bdv/viewer/NavigationActions.java) as an example \"in the wild\".\nFor behaviours (mouse gestures, etc.) the structure is the same. See BigDataViewer's [TransformEventHandler2D](https://github.com/bigdataviewer/bigdataviewer-core/blob/d65e530df8a27726509f477e92c888d280b98162/src/main/java/bdv/TransformEventHandler2D.java) for example.\n\n[![](https://img.shields.io/badge/Download%20-Python%20Notebook%20On%20Github-blue)](https://github.com/imglib/imglib2-www/tree/main/blog_posts/2022-08-08-keymaps)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":"repo"},"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":false,"output-file":"2022-08-08-keymaps.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","sidebar":false,"theme":"cosmo","title-block-banner":true,"title":"User-configurable Keymaps","author":"Tobias Pietzsch","date":"2022-08-08","categories":["ui-behaviour","bigdataviewer"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
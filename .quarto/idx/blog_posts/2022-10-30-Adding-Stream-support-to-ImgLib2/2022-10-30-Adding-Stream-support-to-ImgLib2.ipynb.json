{"title":"Adding Stream support to ImgLib2","markdown":{"yaml":{"title":"Adding Stream support to ImgLib2","author":"Tobias Pietzsch","date":"2022-10-30","categories":["imglib2","stream-api","java"],"execute":{"echo":true}},"headingText":"Adding Stream support to ImgLib2","containsRefs":false,"markdown":"\n> Examples and a discussion on performance \n\n\n\nThis blogpost can also be found at image.sc [https://forum.image.sc/t/adding-stream-support-to-imglib2/88078](https://forum.image.sc/t/adding-stream-support-to-imglib2/88078 )\n\nThe recently released [imglib2-6.3.0](https://maven.scijava.org/#nexus-search;gav~net.imglib2~imglib2~6.3.0~~) adds support for Java Streams.\n\n\n\n## Access Img pixels as a Stream\n\nThe first addition is that every `IterableRealInterval<T>` (and sub-classes like `IterableInterval`, `Img`, ...) can now provide (sequential or parallel) streams over its elements.\n\n\nThis is entirely equivalent to 'java.util.Collection'\n\nand allows to operate on pixel values.\n\nEncounter order of the streams is always compatible with `cursor()`. That is, `Views.flatIterable(img).stream()` yields elements in flat iteration order.\n\nStreams can be used, for example, to set all pixels of an `Img` to some `value`: \n\n\nto compute the sum of all values in an `Img`:\n\nor to find the maximum value in an `Img`:\n\nIn particular the latter two examples, where the terminal operation is some form of reduction, allow for more convenient parallelization than the alternatives. Computing the maximum value in parallel is as simple as \n\nDoing the same with `LoopBuilder` currently requires to parallelize over chunks, collect partial results into mutable holder objects, and implement the reduction of partial results into the final result.\n\n\n## Access Img values *and positions* as a Stream\nA stream of only pixel values, without access to their positions is rather limiting. For example, we would often be interested in the location of the image maximum, not only the value. To achieve this, there is a new utility class `net.imglib2.stream.Streams`, with methods\n\n\nthat allow to create Streams of `LocalizableSampler<T>` of the pixels of an `IterableInterval` (and analogous for `IterableRealInterval`). You can think of `LocalizableSampler<T>` as a `Cursor<T>` which cannot be moved, which is more or less what the default implementation does under the hood.\n\nThe `localizable` and `localizing` variants are analogous to `cursor()` and `localizingCursor()` The Stream returned by `localizable` computes element locations only when asked to (with potentially higher per-element cost). The Stream returned by `localizing` tracks element locations always (in general faster, but potentially unnecessary).\n\nFor example, to fill image pixels with position-dependent values, we would use `localizing`, because we require the position of each element.\n\n![](mandelbrot.jpg \"Mandelbrot\")\n\nConversely, to compute the maximum value and its location in an image, we would use `localizable`, because we only ask for the position of one element (the maximum).\n\n(In both cases, it is fine to chose the respectively other variant with no change in behaviour, and only limited performance impact.)\n\n## Pitfalls\n\nThe `T` elements of the stream are proxies that are re-used, as usual in ImgLib2. Explicit copying operations must be added if stream elements are supposed to be retained (by stateful intermediate or terminal operations).\n\nFor example, to collect all `DoubleType` values between `0` and `1` into a list:\n\n\nThe `.map(DoubleType::copy)` operation is necessary, otherwise the `values` list will contain many duplicates of the same (re-used proxy) `DoubleType` instance. The copy could also be done before the `.filter(...)` operation, but it's better to do it as late as possible to avoid unnecessary creation of objects.\n\nLikewise, the `.map(LocalizableSampler::copy)` in the `printMax()` example above is required. There is [ongoing work](https://github.com/orgs/imglib/projects/1/views/1?pane=issue&itemId=38384066) to reduce the necessity of explicit copy operations. For example, in the `printMax()` example, the `.max()` operation of the stream could be overridden to only copy when a new maximum candidate is encountered.\n\nNote, that already the current implementation takes care not to re-use proxies across parallel execution, so threads of a `parallelStream()` will not interfere.\n\n## Implementation details\n* Both, pure-value streams and value-and-position streams make use of `LocalizableSpliterator<T>`. `LocalizableSpliterator<T>` extends `Spliterator` and `Localizable`, similiar to `Cursor` extending `Iterator` and `Localizable`. \n* There are default `LocalizableSpliterator<T>` (and `RealLocalizableSpliterator<T>`) implementations based on `Cursor<T>` (and `RealCursor<T>`). Therefore, the new streams API works for every `IterableRealInterval`, without the need to touch existing implementations.\n* Additionally, the standard `Img` classes have custom `LocalizableSpliterator<T>`, that leverage knowledge of underlying storage for improved performance.\n\n\n## Performance\nIt's complicated...\n\nOne the one hand, there comes considerable performance overhead in replacing simple loops with stream operations. This has nothing to do with ImgLib2, it is just a \"feature\" of the underlying machinery. This can be observed for example by benchmarking looping over an `int[]` array:\n\n\nThe result is\n\nThat is, the Stream version is > 4 times slower. Equivalent performance overhead often can be observed in ImgLib2, when replacing `Cursor` based loops with Stream operations.\n\nOn the other hand, custom Spliterator implementations sometimes benefit more than cursors from tuning to the underlying storage. (Because iteration is \"internal\" with the spliterator, while the cursor must return control to the caller after every visited element.) For example, consider the following benchmark method (equivalent code for other variations omitted, see [github](https://github.com/imglib/imglib2/blob/dbade5c32a6900145e578ebde0efc12e7a35c436/src/test/java/net/imglib2/stream/LocalizableSamplerStreamBenchmark.java) for full details):\n\n\nThe result looks like\n\nThat is, the performance difference between localizing and non-localizing Cursors is much more pronounced than the difference between Cursor loop and Stream. In fact, the Stream version is even faster than the localizingCursor version. On top of that, it is trivial to parallelize.\n\nFinally, we did not investigate polymorphism effects so far. It is very much possible that this affects performance and we may have to investigate employing `LoopBuilder`s class-copying mechanism to counter these effects.\n\nIn summary, I think one should not hesitate to use Streams where it makes sense from a readability and ease-of-use perspective. If performance is a critical concern, it is best to benchmark various approaches, because the behaviour is not easy to predict.\n\n[![](https://img.shields.io/badge/Download%20-Python%20Notebook%20On%20Github-blue)](https://github.com/imglib/imglib2-www/tree/main/blog_posts/2022-10-30-Adding-Stream-support-to-ImgLib2)\n","srcMarkdownNoYaml":"\n# Adding Stream support to ImgLib2\n> Examples and a discussion on performance \n\n\n\nThis blogpost can also be found at image.sc [https://forum.image.sc/t/adding-stream-support-to-imglib2/88078](https://forum.image.sc/t/adding-stream-support-to-imglib2/88078 )\n\nThe recently released [imglib2-6.3.0](https://maven.scijava.org/#nexus-search;gav~net.imglib2~imglib2~6.3.0~~) adds support for Java Streams.\n\n\n\n## Access Img pixels as a Stream\n\nThe first addition is that every `IterableRealInterval<T>` (and sub-classes like `IterableInterval`, `Img`, ...) can now provide (sequential or parallel) streams over its elements.\n\n\nThis is entirely equivalent to 'java.util.Collection'\n\nand allows to operate on pixel values.\n\nEncounter order of the streams is always compatible with `cursor()`. That is, `Views.flatIterable(img).stream()` yields elements in flat iteration order.\n\nStreams can be used, for example, to set all pixels of an `Img` to some `value`: \n\n\nto compute the sum of all values in an `Img`:\n\nor to find the maximum value in an `Img`:\n\nIn particular the latter two examples, where the terminal operation is some form of reduction, allow for more convenient parallelization than the alternatives. Computing the maximum value in parallel is as simple as \n\nDoing the same with `LoopBuilder` currently requires to parallelize over chunks, collect partial results into mutable holder objects, and implement the reduction of partial results into the final result.\n\n\n## Access Img values *and positions* as a Stream\nA stream of only pixel values, without access to their positions is rather limiting. For example, we would often be interested in the location of the image maximum, not only the value. To achieve this, there is a new utility class `net.imglib2.stream.Streams`, with methods\n\n\nthat allow to create Streams of `LocalizableSampler<T>` of the pixels of an `IterableInterval` (and analogous for `IterableRealInterval`). You can think of `LocalizableSampler<T>` as a `Cursor<T>` which cannot be moved, which is more or less what the default implementation does under the hood.\n\nThe `localizable` and `localizing` variants are analogous to `cursor()` and `localizingCursor()` The Stream returned by `localizable` computes element locations only when asked to (with potentially higher per-element cost). The Stream returned by `localizing` tracks element locations always (in general faster, but potentially unnecessary).\n\nFor example, to fill image pixels with position-dependent values, we would use `localizing`, because we require the position of each element.\n\n![](mandelbrot.jpg \"Mandelbrot\")\n\nConversely, to compute the maximum value and its location in an image, we would use `localizable`, because we only ask for the position of one element (the maximum).\n\n(In both cases, it is fine to chose the respectively other variant with no change in behaviour, and only limited performance impact.)\n\n## Pitfalls\n\nThe `T` elements of the stream are proxies that are re-used, as usual in ImgLib2. Explicit copying operations must be added if stream elements are supposed to be retained (by stateful intermediate or terminal operations).\n\nFor example, to collect all `DoubleType` values between `0` and `1` into a list:\n\n\nThe `.map(DoubleType::copy)` operation is necessary, otherwise the `values` list will contain many duplicates of the same (re-used proxy) `DoubleType` instance. The copy could also be done before the `.filter(...)` operation, but it's better to do it as late as possible to avoid unnecessary creation of objects.\n\nLikewise, the `.map(LocalizableSampler::copy)` in the `printMax()` example above is required. There is [ongoing work](https://github.com/orgs/imglib/projects/1/views/1?pane=issue&itemId=38384066) to reduce the necessity of explicit copy operations. For example, in the `printMax()` example, the `.max()` operation of the stream could be overridden to only copy when a new maximum candidate is encountered.\n\nNote, that already the current implementation takes care not to re-use proxies across parallel execution, so threads of a `parallelStream()` will not interfere.\n\n## Implementation details\n* Both, pure-value streams and value-and-position streams make use of `LocalizableSpliterator<T>`. `LocalizableSpliterator<T>` extends `Spliterator` and `Localizable`, similiar to `Cursor` extending `Iterator` and `Localizable`. \n* There are default `LocalizableSpliterator<T>` (and `RealLocalizableSpliterator<T>`) implementations based on `Cursor<T>` (and `RealCursor<T>`). Therefore, the new streams API works for every `IterableRealInterval`, without the need to touch existing implementations.\n* Additionally, the standard `Img` classes have custom `LocalizableSpliterator<T>`, that leverage knowledge of underlying storage for improved performance.\n\n\n## Performance\nIt's complicated...\n\nOne the one hand, there comes considerable performance overhead in replacing simple loops with stream operations. This has nothing to do with ImgLib2, it is just a \"feature\" of the underlying machinery. This can be observed for example by benchmarking looping over an `int[]` array:\n\n\nThe result is\n\nThat is, the Stream version is > 4 times slower. Equivalent performance overhead often can be observed in ImgLib2, when replacing `Cursor` based loops with Stream operations.\n\nOn the other hand, custom Spliterator implementations sometimes benefit more than cursors from tuning to the underlying storage. (Because iteration is \"internal\" with the spliterator, while the cursor must return control to the caller after every visited element.) For example, consider the following benchmark method (equivalent code for other variations omitted, see [github](https://github.com/imglib/imglib2/blob/dbade5c32a6900145e578ebde0efc12e7a35c436/src/test/java/net/imglib2/stream/LocalizableSamplerStreamBenchmark.java) for full details):\n\n\nThe result looks like\n\nThat is, the performance difference between localizing and non-localizing Cursors is much more pronounced than the difference between Cursor loop and Stream. In fact, the Stream version is even faster than the localizingCursor version. On top of that, it is trivial to parallelize.\n\nFinally, we did not investigate polymorphism effects so far. It is very much possible that this affects performance and we may have to investigate employing `LoopBuilder`s class-copying mechanism to counter these effects.\n\nIn summary, I think one should not hesitate to use Streams where it makes sense from a readability and ease-of-use perspective. If performance is a critical concern, it is best to benchmark various approaches, because the behaviour is not easy to predict.\n\n[![](https://img.shields.io/badge/Download%20-Python%20Notebook%20On%20Github-blue)](https://github.com/imglib/imglib2-www/tree/main/blog_posts/2022-10-30-Adding-Stream-support-to-ImgLib2)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":"repo"},"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":false,"output-file":"2022-10-30-Adding-Stream-support-to-ImgLib2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","sidebar":false,"theme":"cosmo","title-block-banner":true,"title":"Adding Stream support to ImgLib2","author":"Tobias Pietzsch","date":"2022-10-30","categories":["imglib2","stream-api","java"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}